Device driver patches for accton as5512 (fan/psu/cpld/led/sfp)

diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
index 89c619d..968bd5f 100644
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -1574,6 +1574,24 @@ config SENSORS_ACCTON_AS5812_54t_PSU
 	  This driver can also be built as a module. If so, the module will
 	  be called accton_as5812_54t_psu.
 	  
+config SENSORS_ACCTON_AS5512_54X_PSU
+	tristate "Accton as5512 54x psu"
+	depends on I2C && SENSORS_ACCTON_I2C_CPLD
+	help
+	  If you say yes here you get support for Accton as5512 54x psu.
+
+	  This driver can also be built as a module. If so, the module will
+	  be called accton_as5512_54x_psu.	  
+
+config SENSORS_ACCTON_AS5512_54X_FAN
+	tristate "Accton as5512 54x fan"
+	depends on I2C && SENSORS_ACCTON_I2C_CPLD
+	help
+	  If you say yes here you get support for Accton as5512 54x fan.
+
+	  This driver can also be built as a module. If so, the module will
+	  be called accton_as5512_54x_fan.
+
 if ACPI
 
 comment "ACPI drivers"
diff --git a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
index de922bc..b8ee7b0 100644
--- a/drivers/hwmon/Makefile
+++ b/drivers/hwmon/Makefile
@@ -36,6 +36,8 @@ obj-$(CONFIG_SENSORS_ACCTON_AS6812_32x_FAN)    += accton_as6812_32x_fan.o
 obj-$(CONFIG_SENSORS_ACCTON_AS6812_32x_PSU)    += accton_as6812_32x_psu.o
 obj-$(CONFIG_SENSORS_ACCTON_AS5812_54t_FAN)    += accton_as5812_54t_fan.o
 obj-$(CONFIG_SENSORS_ACCTON_AS5812_54t_PSU)    += accton_as5812_54t_psu.o
+obj-$(CONFIG_SENSORS_ACCTON_AS5512_54X_PSU)    += accton_as5512_54x_psu.o
+obj-$(CONFIG_SENSORS_ACCTON_AS5512_54X_FAN)    += accton_as5512_54x_fan.o
 obj-$(CONFIG_SENSORS_AD7314)	+= ad7314.o
 obj-$(CONFIG_SENSORS_AD7414)	+= ad7414.o
 obj-$(CONFIG_SENSORS_AD7418)	+= ad7418.o
diff --git a/drivers/hwmon/accton_as5512_54x_fan.c b/drivers/hwmon/accton_as5512_54x_fan.c
new file mode 100644
index 0000000..67e3dd6
--- /dev/null
+++ b/drivers/hwmon/accton_as5512_54x_fan.c
@@ -0,0 +1,454 @@
+/*
+ * A hwmon driver for the Accton as5512 54x fan control
+ *
+ * Copyright (C) 2015 Accton Technology Corporation.
+ * Brandon Chuang <brandon_chuang@accton.com.tw>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/jiffies.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/sysfs.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/syscalls.h>
+#include <linux/kthread.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+
+#define FAN_MAX_NUMBER                   5
+#define FAN_SPEED_CPLD_TO_RPM_STEP       150
+#define FAN_SPEED_PRECENT_TO_CPLD_STEP   5
+#define FAN_DUTY_CYCLE_MIN               0
+#define FAN_DUTY_CYCLE_MAX               100  /* 100% */
+
+#define CPLD_REG_FAN_STATUS_OFFSET        0x0C
+#define CPLD_REG_FANR_STATUS_OFFSET       0x1E
+#define CPLD_REG_FAN_DIRECTION_OFFSET     0x1D
+
+#define CPLD_FAN1_REG_SPEED_OFFSET       0x10
+#define CPLD_FAN2_REG_SPEED_OFFSET       0x11
+#define CPLD_FAN3_REG_SPEED_OFFSET       0x12
+#define CPLD_FAN4_REG_SPEED_OFFSET       0x13
+#define CPLD_FAN5_REG_SPEED_OFFSET       0x14
+
+#define CPLD_FANR1_REG_SPEED_OFFSET      0x18
+#define CPLD_FANR2_REG_SPEED_OFFSET      0x19
+#define CPLD_FANR3_REG_SPEED_OFFSET      0x1A
+#define CPLD_FANR4_REG_SPEED_OFFSET      0x1B
+#define CPLD_FANR5_REG_SPEED_OFFSET      0x1C
+
+#define CPLD_REG_FAN_PWM_CYCLE_OFFSET      0x0D
+
+#define CPLD_FAN1_INFO_BIT_MASK           0x01
+#define CPLD_FAN2_INFO_BIT_MASK           0x02
+#define CPLD_FAN3_INFO_BIT_MASK           0x04
+#define CPLD_FAN4_INFO_BIT_MASK           0x08
+#define CPLD_FAN5_INFO_BIT_MASK           0x10
+
+#define PROJECT_NAME                      
+
+#define LOCAL_DEBUG                       0
+
+static struct accton_as5512_54x_fan  *fan_data = NULL;
+
+struct accton_as5512_54x_fan {
+    struct platform_device *pdev;
+    struct device   *hwmon_dev;
+    struct mutex     update_lock;
+    char             valid;           /* != 0 if registers are valid */
+    unsigned long    last_updated;    /* In jiffies */
+    u8               status[FAN_MAX_NUMBER];     /* inner first fan status */
+    u32              speed[FAN_MAX_NUMBER];      /* inner first fan speed */
+    u8               direction[FAN_MAX_NUMBER];  /* reconrd the direction of inner first and second fans */
+    u32              duty_cycle[FAN_MAX_NUMBER]; /* control the speed of inner first and second fans */
+    u8               r_status[FAN_MAX_NUMBER];   /* inner second fan status */
+    u32              r_speed[FAN_MAX_NUMBER];    /* inner second fan speed */
+};
+
+/*******************/
+#define MAKE_FAN_MASK_OR_REG(name,type) \
+    CPLD_FAN##type##1_##name,      \
+    CPLD_FAN##type##2_##name,      \
+    CPLD_FAN##type##3_##name,      \
+    CPLD_FAN##type##4_##name,      \
+    CPLD_FAN##type##5_##name,          
+
+/* fan related data
+ */
+static const u8 fan_info_mask[] = {
+    MAKE_FAN_MASK_OR_REG(INFO_BIT_MASK,)
+};
+
+static const u8 fan_speed_reg[] = {
+    MAKE_FAN_MASK_OR_REG(REG_SPEED_OFFSET,)
+};
+
+static const u8 fanr_speed_reg[] = {
+    MAKE_FAN_MASK_OR_REG(REG_SPEED_OFFSET,R)
+};
+
+/*******************/
+#define DEF_FAN_SET(id) \
+    FAN##id##_FAULT,      \
+    FAN##id##_SPEED,      \
+    FAN##id##_DUTY_CYCLE, \
+    FAN##id##_DIRECTION,  \
+    FANR##id##_FAULT,    \
+    FANR##id##_SPEED,
+    
+enum sysfs_fan_attributes {
+    DEF_FAN_SET(1)
+    DEF_FAN_SET(2)
+    DEF_FAN_SET(3)
+    DEF_FAN_SET(4)
+    DEF_FAN_SET(5)
+};
+/*******************/
+static void accton_as5512_54x_fan_update_device(struct device *dev);
+static int accton_as5512_54x_fan_read_value(u8 reg);
+static int accton_as5512_54x_fan_write_value(u8 reg, u8 value);
+                                             
+static ssize_t fan_set_duty_cycle(struct device *dev, 
+                    struct device_attribute *da,const char *buf, size_t count);
+static ssize_t fan_show_value(struct device *dev, 
+                    struct device_attribute *da, char *buf);
+
+extern int accton_i2c_cpld_read(unsigned short cpld_addr, u8 reg);
+extern int accton_i2c_cpld_write(unsigned short cpld_addr, u8 reg, u8 value);
+
+                    
+/*******************/
+#define _MAKE_SENSOR_DEVICE_ATTR(prj, id) \
+    static SENSOR_DEVICE_ATTR(prj##fan##id##_fault, S_IRUGO, fan_show_value, NULL, FAN##id##_FAULT); \
+    static SENSOR_DEVICE_ATTR(prj##fan##id##_speed_rpm, S_IRUGO, fan_show_value, NULL, FAN##id##_SPEED); \
+    static SENSOR_DEVICE_ATTR(prj##fan##id##_direction, S_IRUGO, fan_show_value, NULL, FAN##id##_DIRECTION); \
+    static SENSOR_DEVICE_ATTR(prj##fanr##id##_fault, S_IRUGO, fan_show_value, NULL, FANR##id##_FAULT); \
+    static SENSOR_DEVICE_ATTR(prj##fanr##id##_speed_rpm, S_IRUGO, fan_show_value, NULL, FANR##id##_SPEED); 
+
+#define MAKE_SENSOR_DEVICE_ATTR(prj,id) _MAKE_SENSOR_DEVICE_ATTR(prj,id) 
+
+#define _MAKE_SENSOR_DEVICE_ATTR_FAN_DUTY(prj,id) \
+    static SENSOR_DEVICE_ATTR(prj##fan##id##_duty_cycle_percentage, S_IWUSR | S_IRUGO, fan_show_value,          \
+                                            fan_set_duty_cycle, FAN1_DUTY_CYCLE);
+
+#define MAKE_SENSOR_DEVICE_ATTR_FAN_DUTY(prj,id) _MAKE_SENSOR_DEVICE_ATTR_FAN_DUTY(prj,id)
+
+
+MAKE_SENSOR_DEVICE_ATTR(PROJECT_NAME, 1)                  
+MAKE_SENSOR_DEVICE_ATTR(PROJECT_NAME, 2)
+MAKE_SENSOR_DEVICE_ATTR(PROJECT_NAME, 3)
+MAKE_SENSOR_DEVICE_ATTR(PROJECT_NAME, 4)
+MAKE_SENSOR_DEVICE_ATTR(PROJECT_NAME, 5)
+MAKE_SENSOR_DEVICE_ATTR_FAN_DUTY(PROJECT_NAME,)
+/*******************/
+
+#define _MAKE_FAN_ATTR(prj, id) \
+    &sensor_dev_attr_##prj##fan##id##_fault.dev_attr.attr,     \
+    &sensor_dev_attr_##prj##fan##id##_speed_rpm.dev_attr.attr,     \
+    &sensor_dev_attr_##prj##fan##id##_direction.dev_attr.attr, \
+    &sensor_dev_attr_##prj##fanr##id##_fault.dev_attr.attr,   \
+    &sensor_dev_attr_##prj##fanr##id##_speed_rpm.dev_attr.attr,  
+
+#define MAKE_FAN_ATTR(prj, id) _MAKE_FAN_ATTR(prj, id) 
+
+#define _MAKE_FAN_DUTY_ATTR(prj, id) \
+    &sensor_dev_attr_##prj##fan##id##_duty_cycle_percentage.dev_attr.attr,
+
+#define MAKE_FAN_DUTY_ATTR(prj, id) _MAKE_FAN_DUTY_ATTR(prj, id)
+
+static struct attribute *accton_as5512_54x_fan_attributes[] = {
+    /* fan related attributes */
+    MAKE_FAN_ATTR(PROJECT_NAME,1)                  
+    MAKE_FAN_ATTR(PROJECT_NAME,2)
+    MAKE_FAN_ATTR(PROJECT_NAME,3)                  
+    MAKE_FAN_ATTR(PROJECT_NAME,4)
+    MAKE_FAN_ATTR(PROJECT_NAME,5)
+	MAKE_FAN_DUTY_ATTR(PROJECT_NAME,)
+    NULL
+};
+/*******************/
+
+/* fan related functions
+ */
+static ssize_t fan_show_value(struct device *dev, struct device_attribute *da,
+             char *buf)
+{
+    struct  sensor_device_attribute *attr = to_sensor_dev_attr(da);
+    ssize_t ret = 0;
+    int     data_index, type_index;
+    
+    accton_as5512_54x_fan_update_device(dev);
+
+    if (fan_data->valid == 0) {
+        return ret;
+    }
+
+    type_index = attr->index%FAN2_FAULT;
+    data_index = attr->index/FAN2_FAULT;
+     
+    switch (type_index) {
+        case FAN1_FAULT:
+            ret = sprintf(buf, "%d\n", fan_data->status[data_index]);
+            if (LOCAL_DEBUG)        
+                printk ("[Check !!][%s][%d][type->index=%d][data->index=%d]\n", __FUNCTION__, __LINE__, type_index, data_index);  
+            break;
+        case FAN1_SPEED:
+            ret = sprintf(buf, "%d\n", fan_data->speed[data_index]);
+            if (LOCAL_DEBUG)        
+                printk ("[Check !!][%s][%d][type->index=%d][data->index=%d]\n", __FUNCTION__, __LINE__, type_index, data_index);  
+            break;
+        case FAN1_DUTY_CYCLE:
+            ret = sprintf(buf, "%d\n", fan_data->duty_cycle[data_index]);
+            if (LOCAL_DEBUG)        
+                printk ("[Check !!][%s][%d][type->index=%d][data->index=%d]\n", __FUNCTION__, __LINE__, type_index, data_index);  
+            break;
+        case FAN1_DIRECTION:
+            ret = sprintf(buf, "%d\n", fan_data->direction[data_index]);   /* presnet, need to modify*/
+            if (LOCAL_DEBUG)        
+                printk ("[Check !!][%s][%d][type->index=%d][data->index=%d]\n", __FUNCTION__, __LINE__, type_index, data_index);  
+            break;  
+        case FANR1_FAULT:
+            ret = sprintf(buf, "%d\n", fan_data->r_status[data_index]);
+            if (LOCAL_DEBUG)        
+                printk ("[Check !!][%s][%d][type->index=%d][data->index=%d]\n", __FUNCTION__, __LINE__, type_index, data_index);  
+            break;
+        case FANR1_SPEED:
+            ret = sprintf(buf, "%d\n", fan_data->r_speed[data_index]);
+            if (LOCAL_DEBUG)        
+                printk ("[Check !!][%s][%d][type->index=%d][data->index=%d]\n", __FUNCTION__, __LINE__, type_index, data_index);  
+            break;
+        default:
+            if (LOCAL_DEBUG)        
+                printk ("[Check !!][%s][%d] \n", __FUNCTION__, __LINE__);      
+            break;
+    }
+    
+    return ret;
+}
+/*******************/
+static ssize_t fan_set_duty_cycle(struct device *dev, struct device_attribute *da,
+            const char *buf, size_t count) {
+
+    int error, value;
+    
+    error = kstrtoint(buf, 10, &value);
+    if (error)
+        return error;
+        
+    if (value < FAN_DUTY_CYCLE_MIN || value > FAN_DUTY_CYCLE_MAX)
+        return -EINVAL;
+
+    accton_as5512_54x_fan_write_value(CPLD_REG_FAN_PWM_CYCLE_OFFSET, value/FAN_SPEED_PRECENT_TO_CPLD_STEP);
+    
+    fan_data->valid = 0;
+
+    return count;
+}
+
+static const struct attribute_group accton_as5512_54x_fan_group = {
+    .attrs = accton_as5512_54x_fan_attributes,
+};
+
+static int accton_as5512_54x_fan_read_value(u8 reg)
+{
+    return accton_i2c_cpld_read(0x60, reg);
+}
+
+static int accton_as5512_54x_fan_write_value(u8 reg, u8 value)
+{
+    return accton_i2c_cpld_write(0x60, reg, value);
+}
+
+static void accton_as5512_54x_fan_update_device(struct device *dev)
+{
+    int speed, r_speed, fault, r_fault, ctrl_speed, direction;
+    int i;
+    
+    mutex_lock(&fan_data->update_lock);
+
+    if (LOCAL_DEBUG)        
+        printk ("Starting accton_as5512_54x_fan update \n");    
+
+    if (!(time_after(jiffies, fan_data->last_updated + HZ + HZ / 2) || !fan_data->valid)) {
+        /* do nothing */
+        goto _exit; 
+    }
+
+    fan_data->valid = 0;
+        
+    if (LOCAL_DEBUG)        
+        printk ("Starting accton_as5512_54x_fan update 2 \n");    
+
+    fault      = accton_as5512_54x_fan_read_value(CPLD_REG_FAN_STATUS_OFFSET);
+    r_fault    = accton_as5512_54x_fan_read_value(CPLD_REG_FANR_STATUS_OFFSET);    
+    direction  = accton_as5512_54x_fan_read_value(CPLD_REG_FAN_DIRECTION_OFFSET);
+    ctrl_speed = accton_as5512_54x_fan_read_value(CPLD_REG_FAN_PWM_CYCLE_OFFSET);
+    
+    if ( (fault < 0) || (r_fault < 0) || (direction < 0) || (ctrl_speed < 0) )
+    {        
+        if (LOCAL_DEBUG)        
+            printk ("[Error!!][%s][%d] \n", __FUNCTION__, __LINE__);            
+        goto _exit; /* error */ 
+    }
+
+    if (LOCAL_DEBUG)        
+        printk ("[fan:] fault:%d, r_fault=%d, direction=%d, ctrl_speed=%d \n",fault, r_fault, direction, ctrl_speed);    
+
+    for (i=0; i<FAN_MAX_NUMBER; i++)
+    {
+        /* Update fan data
+         */
+
+        /* fan fault 
+         * 0: normal, 1:abnormal
+         * Each FAN-tray module has two fans.
+         */
+        fan_data->status[i]     = (fault     & fan_info_mask[i]) >> i;
+        if (LOCAL_DEBUG)        
+            printk ("[fan%d:] fail=%d \n",i, fan_data->status[i]);    
+        
+        fan_data->r_status[i]   = (r_fault   & fan_info_mask[i]) >> i;
+        fan_data->direction[i]  = (direction & fan_info_mask[i]) >> i;
+        fan_data->duty_cycle[i] = ctrl_speed * FAN_SPEED_PRECENT_TO_CPLD_STEP;
+        
+        /* fan speed 
+         */
+        speed      = accton_as5512_54x_fan_read_value(fan_speed_reg[i]);
+        r_speed    = accton_as5512_54x_fan_read_value(fanr_speed_reg[i]);
+        if ( (speed < 0) || (r_speed < 0) )
+        {      
+            if (LOCAL_DEBUG)        
+                printk ("[Error!!][%s][%d] \n", __FUNCTION__, __LINE__);      
+            goto _exit; /* error */ 
+        }
+
+        if (LOCAL_DEBUG)        
+            printk ("[fan%d:] speed:%d, r_speed=%d \n", i, speed, r_speed);    
+        
+        fan_data->speed[i]   = speed   * FAN_SPEED_CPLD_TO_RPM_STEP;
+        fan_data->r_speed[i] = r_speed * FAN_SPEED_CPLD_TO_RPM_STEP;
+    }
+    
+    /* finish to update */
+    fan_data->last_updated = jiffies;
+    fan_data->valid = 1;
+
+_exit:    
+    mutex_unlock(&fan_data->update_lock);
+}
+
+static int accton_as5512_54x_fan_probe(struct platform_device *pdev)
+{
+    int status = -1;
+
+    /* Register sysfs hooks */
+    status = sysfs_create_group(&pdev->dev.kobj, &accton_as5512_54x_fan_group);
+    if (status) {
+        goto exit;
+
+    }
+    
+	fan_data->hwmon_dev = hwmon_device_register(&pdev->dev);
+	if (IS_ERR(fan_data->hwmon_dev)) {
+		status = PTR_ERR(fan_data->hwmon_dev);
+		goto exit_remove;
+	}
+
+    dev_info(&pdev->dev, "accton_as5512_54x_fan\n");
+    
+    return 0;
+    
+exit_remove:
+    sysfs_remove_group(&pdev->dev.kobj, &accton_as5512_54x_fan_group);
+exit:
+    return status;
+}
+
+static int accton_as5512_54x_fan_remove(struct platform_device *pdev)
+{
+    hwmon_device_unregister(fan_data->hwmon_dev);
+    sysfs_remove_group(&fan_data->pdev->dev.kobj, &accton_as5512_54x_fan_group);
+    
+    return 0;
+}
+
+#define DRVNAME "as5512_54x_fan"
+
+static struct platform_driver accton_as5512_54x_fan_driver = {
+    .probe      = accton_as5512_54x_fan_probe,
+    .remove     = accton_as5512_54x_fan_remove,
+    .driver     = {
+        .name   = DRVNAME,
+        .owner  = THIS_MODULE,
+    },
+};
+
+static int __init accton_as5512_54x_fan_init(void)
+{
+    int ret;
+
+    extern int platform_accton_as5512_54x(void);
+    if(!platform_accton_as5512_54x()) {
+        return -ENODEV;
+    }
+
+    ret = platform_driver_register(&accton_as5512_54x_fan_driver);
+    if (ret < 0) {
+        goto exit;
+    }
+        
+    fan_data = kzalloc(sizeof(struct accton_as5512_54x_fan), GFP_KERNEL);
+    if (!fan_data) {
+        ret = -ENOMEM;
+        platform_driver_unregister(&accton_as5512_54x_fan_driver);
+        goto exit;
+    }
+
+	mutex_init(&fan_data->update_lock);
+    fan_data->valid = 0;
+	
+    fan_data->pdev = platform_device_register_simple(DRVNAME, -1, NULL, 0);
+    if (IS_ERR(fan_data->pdev)) {
+        ret = PTR_ERR(fan_data->pdev);
+        platform_driver_unregister(&accton_as5512_54x_fan_driver);
+        kfree(fan_data);
+        goto exit;
+    }
+
+exit:
+    return ret;
+}
+
+static void __exit accton_as5512_54x_fan_exit(void)
+{
+    platform_device_unregister(fan_data->pdev);
+    platform_driver_unregister(&accton_as5512_54x_fan_driver);
+    kfree(fan_data);
+}
+
+MODULE_AUTHOR("Brandon Chuang <brandon_chuang@accton.com.tw>");
+MODULE_DESCRIPTION("accton_as5512_54x_fan driver");
+MODULE_LICENSE("GPL");
+
+module_init(accton_as5512_54x_fan_init);
+module_exit(accton_as5512_54x_fan_exit);
+
+
diff --git a/drivers/hwmon/accton_as5512_54x_psu.c b/drivers/hwmon/accton_as5512_54x_psu.c
new file mode 100644
index 0000000..66d61f3
--- /dev/null
+++ b/drivers/hwmon/accton_as5512_54x_psu.c
@@ -0,0 +1,295 @@
+/*
+ * An hwmon driver for accton as5512_54x Power Module
+ *
+ * Copyright (C) 2015 Accton Technology Corporation.
+ * Brandon Chuang <brandon_chuang@accton.com.tw>
+ *
+ * Based on ad7414.c
+ * Copyright 2006 Stefan Roese <sr at denx.de>, DENX Software Engineering
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/sysfs.h>
+#include <linux/slab.h>
+
+static ssize_t show_index(struct device *dev, struct device_attribute *da, char *buf);
+static ssize_t show_status(struct device *dev, struct device_attribute *da, char *buf);
+static ssize_t show_model_name(struct device *dev, struct device_attribute *da, char *buf);
+static int as5512_54x_psu_read_block(struct i2c_client *client, u8 command, u8 *data,int data_len);
+extern int accton_i2c_cpld_read(unsigned short cpld_addr, u8 reg);
+
+/* Addresses scanned 
+ */
+static const unsigned short normal_i2c[] = { 0x38, 0x3b, 0x50, 0x53, I2C_CLIENT_END };
+
+/* Each client has this additional data 
+ */
+struct as5512_54x_psu_data {
+    struct device      *hwmon_dev;
+    struct mutex        update_lock;
+    char                valid;           /* !=0 if registers are valid */
+    unsigned long       last_updated;    /* In jiffies */
+    u8  index;           /* PSU index */
+    u8  status;          /* Status(present/power_good) register read from CPLD */
+    char model_name[14]; /* Model name, read from eeprom */
+};
+
+static struct as5512_54x_psu_data *as5512_54x_psu_update_device(struct device *dev);             
+
+enum as5512_54x_psu_sysfs_attributes {
+    PSU_INDEX,
+    PSU_PRESENT,
+    PSU_MODEL_NAME,
+    PSU_POWER_GOOD
+};
+
+/* sysfs attributes for hwmon 
+ */
+static SENSOR_DEVICE_ATTR(psu_index,      S_IRUGO, show_index,     NULL, PSU_INDEX);
+static SENSOR_DEVICE_ATTR(psu_present,    S_IRUGO, show_status,    NULL, PSU_PRESENT);
+static SENSOR_DEVICE_ATTR(psu_model_name, S_IRUGO, show_model_name,NULL, PSU_MODEL_NAME);
+static SENSOR_DEVICE_ATTR(psu_power_good, S_IRUGO, show_status,    NULL, PSU_POWER_GOOD);
+
+static struct attribute *as5512_54x_psu_attributes[] = {
+    &sensor_dev_attr_psu_index.dev_attr.attr,
+    &sensor_dev_attr_psu_present.dev_attr.attr,
+    &sensor_dev_attr_psu_model_name.dev_attr.attr,
+    &sensor_dev_attr_psu_power_good.dev_attr.attr,
+    NULL
+};
+
+static ssize_t show_index(struct device *dev, struct device_attribute *da,
+             char *buf)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct as5512_54x_psu_data *data = i2c_get_clientdata(client);
+    
+    return sprintf(buf, "%d\n", data->index);
+}
+
+static ssize_t show_status(struct device *dev, struct device_attribute *da,
+             char *buf)
+{
+    struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+    struct as5512_54x_psu_data *data = as5512_54x_psu_update_device(dev);
+    u8 status = 0;
+
+    if (attr->index == PSU_PRESENT) {
+        status = !(data->status >> ((data->index - 1) * 4) & 0x1);
+    }
+    else { /* PSU_POWER_GOOD */
+        status = data->status >> ((data->index - 1) * 4 + 1) & 0x1;
+    }
+
+    return sprintf(buf, "%d\n", status);
+}
+
+static ssize_t show_model_name(struct device *dev, struct device_attribute *da,
+             char *buf)
+{
+    struct as5512_54x_psu_data *data = as5512_54x_psu_update_device(dev);
+    
+    return sprintf(buf, "%s", data->model_name);
+}
+
+static const struct attribute_group as5512_54x_psu_group = {
+    .attrs = as5512_54x_psu_attributes,
+};
+
+static int as5512_54x_psu_probe(struct i2c_client *client,
+            const struct i2c_device_id *dev_id)
+{
+    struct as5512_54x_psu_data *data;
+    int status;
+
+    if (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_I2C_BLOCK)) {
+        status = -EIO;
+        goto exit;
+    }
+
+    data = kzalloc(sizeof(struct as5512_54x_psu_data), GFP_KERNEL);
+    if (!data) {
+        status = -ENOMEM;
+        goto exit;
+    }
+
+    i2c_set_clientdata(client, data);
+    data->valid = 0;
+    mutex_init(&data->update_lock);
+
+    dev_info(&client->dev, "chip found\n");
+
+    /* Register sysfs hooks */
+    status = sysfs_create_group(&client->dev.kobj, &as5512_54x_psu_group);
+    if (status) {
+        goto exit_free;
+    }
+
+    data->hwmon_dev = hwmon_device_register(&client->dev);
+    if (IS_ERR(data->hwmon_dev)) {
+        status = PTR_ERR(data->hwmon_dev);
+        goto exit_remove;
+    }
+
+    /* Update PSU index */
+    if (client->addr == 0x38 || client->addr == 0x50) {
+        data->index = 1;
+    }
+    else if (client->addr == 0x3b || client->addr == 0x53) {
+        data->index = 2;
+    }
+
+    dev_info(&client->dev, "%s: psu '%s'\n",
+         dev_name(data->hwmon_dev), client->name);
+    
+    return 0;
+
+exit_remove:
+    sysfs_remove_group(&client->dev.kobj, &as5512_54x_psu_group);
+exit_free:
+    kfree(data);
+exit:
+    
+    return status;
+}
+
+static int as5512_54x_psu_remove(struct i2c_client *client)
+{
+    struct as5512_54x_psu_data *data = i2c_get_clientdata(client);
+
+    hwmon_device_unregister(data->hwmon_dev);
+    sysfs_remove_group(&client->dev.kobj, &as5512_54x_psu_group);
+    kfree(data);
+    
+    return 0;
+}
+
+static const struct i2c_device_id as5512_54x_psu_id[] = {
+    { "as5512_54x_psu", 0 },
+    {}
+};
+MODULE_DEVICE_TABLE(i2c, as5512_54x_psu_id);
+
+static struct i2c_driver as5512_54x_psu_driver = {
+    .class        = I2C_CLASS_HWMON,
+    .driver = {
+        .name     = "as5512_54x_psu",
+    },
+    .probe        = as5512_54x_psu_probe,
+    .remove       = as5512_54x_psu_remove,
+    .id_table     = as5512_54x_psu_id,
+    .address_list = normal_i2c,
+};
+
+static int as5512_54x_psu_read_block(struct i2c_client *client, u8 command, u8 *data,
+              int data_len)
+{
+    int result = i2c_smbus_read_i2c_block_data(client, command, data_len, data);
+    
+    if (unlikely(result < 0))
+        goto abort;
+    if (unlikely(result != data_len)) {
+        result = -EIO;
+        goto abort;
+    }
+    
+    result = 0;
+    
+abort:
+    return result;
+}
+
+static struct as5512_54x_psu_data *as5512_54x_psu_update_device(struct device *dev)
+{
+    struct i2c_client *client = to_i2c_client(dev);
+    struct as5512_54x_psu_data *data = i2c_get_clientdata(client);
+    
+    mutex_lock(&data->update_lock);
+
+    if (time_after(jiffies, data->last_updated + HZ + HZ / 2)
+        || !data->valid) {
+        int status = -1;
+
+        dev_dbg(&client->dev, "Starting as5512_54x update\n");
+
+        /* Read model name */
+        if (client->addr == 0x38 || client->addr == 0x3b) {
+            /* AC power */
+            status = as5512_54x_psu_read_block(client, 0x26, data->model_name, 
+                                               ARRAY_SIZE(data->model_name)-1);
+        }
+        else {
+            /* DC power */
+            status = as5512_54x_psu_read_block(client, 0x50, data->model_name, 
+                                               ARRAY_SIZE(data->model_name)-1);            
+        }
+        
+        if (status < 0) {
+            data->model_name[0] = '\0';
+            dev_dbg(&client->dev, "unable to read model name from (0x%x)\n", client->addr);
+        }
+        else {
+            data->model_name[ARRAY_SIZE(data->model_name)-1] = '\0';
+        }
+
+        /* Read psu status */
+        status = accton_i2c_cpld_read(0x60, 0x2);
+        
+        if (status < 0) {
+            dev_dbg(&client->dev, "cpld reg 0x60 err %d\n", status);
+        }
+        else {
+            data->status = status;
+        }
+        
+        data->last_updated = jiffies;
+        data->valid = 1;
+    }
+
+    mutex_unlock(&data->update_lock);
+
+    return data;
+}
+
+static int __init as5512_54x_psu_init(void)
+{
+    extern int platform_accton_as5512_54x(void);
+    if(!platform_accton_as5512_54x()) {
+        return -ENODEV;
+    }
+
+    return i2c_add_driver(&as5512_54x_psu_driver);
+}
+
+static void __exit as5512_54x_psu_exit(void)
+{
+    i2c_del_driver(&as5512_54x_psu_driver);
+}
+
+MODULE_AUTHOR("Brandon Chuang <brandon_chuang@accton.com.tw>");
+MODULE_DESCRIPTION("accton as5512_54x_psu driver");
+MODULE_LICENSE("GPL");
+
+module_init(as5512_54x_psu_init);
+module_exit(as5512_54x_psu_exit);
+
diff --git a/drivers/hwmon/accton_i2c_cpld.c b/drivers/hwmon/accton_i2c_cpld.c
index acf88c9..e50c599 100644
--- a/drivers/hwmon/accton_i2c_cpld.c
+++ b/drivers/hwmon/accton_i2c_cpld.c
@@ -255,6 +255,22 @@ int platform_accton_as5812_54t(void)
 }
 EXPORT_SYMBOL(platform_accton_as5812_54t);
 
+static struct dmi_system_id as5512_54x_dmi_table[] = {
+	{
+		.ident = "Accton AS5512",
+		.matches = {
+			DMI_MATCH(DMI_BOARD_VENDOR, "Accton"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "AS5512"),
+		},
+	}
+};
+
+int platform_accton_as5512_54x(void)
+{
+	return dmi_check_system(as5512_54x_dmi_table);
+}
+EXPORT_SYMBOL(platform_accton_as5512_54x);
+
 MODULE_AUTHOR("Brandon Chuang <brandon_chuang@accton.com.tw>");
 MODULE_DESCRIPTION("accton_i2c_cpld driver");
 MODULE_LICENSE("GPL");
diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
index 599b97b..9ba4a1b 100644
--- a/drivers/leds/Kconfig
+++ b/drivers/leds/Kconfig
@@ -88,7 +88,14 @@ config LEDS_ACCTON_AS5812_54t
 	help
 	  This option enables support for the LEDs on the Accton as5812 54t.
 	  Say Y to enable LEDs on the Accton as5812 54t.
-	  
+
+config LEDS_ACCTON_AS5512_54X
+	tristate "LED support for the Accton as5512 54x"
+	depends on LEDS_CLASS && SENSORS_ACCTON_I2C_CPLD
+	help
+	  This option enables support for the LEDs on the Accton as5512 54x.
+	  Say Y to enable LEDs on the Accton as5512 54x.
+
 config LEDS_LM3530
 	tristate "LCD Backlight driver for LM3530"
 	depends on LEDS_CLASS
diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
index bd20baa..ff3be6c 100644
--- a/drivers/leds/Makefile
+++ b/drivers/leds/Makefile
@@ -50,6 +50,7 @@ obj-$(CONFIG_LEDS_ACCTON_AS7712_32x) += leds-accton_as7712_32x.o
 obj-$(CONFIG_LEDS_ACCTON_AS5812_54x) += leds-accton_as5812_54x.o
 obj-$(CONFIG_LEDS_ACCTON_AS6812_32x) += leds-accton_as6812_32x.o
 obj-$(CONFIG_LEDS_ACCTON_AS5812_54t) += leds-accton_as5812_54t.o
+obj-$(CONFIG_LEDS_ACCTON_AS5512_54X) += leds-accton_as5512_54x.o
 
 # LED SPI Drivers
 obj-$(CONFIG_LEDS_DAC124S085)		+= leds-dac124s085.o
diff --git a/drivers/leds/leds-accton_as5512_54x.c b/drivers/leds/leds-accton_as5512_54x.c
new file mode 100644
index 0000000..761483a
--- /dev/null
+++ b/drivers/leds/leds-accton_as5512_54x.c
@@ -0,0 +1,463 @@
+/*
+ * A LED driver for the accton_as5512_54x_led
+ *
+ * Copyright (C) 2015 Accton Technology Corporation.
+ * Brandon Chuang <brandon_chuang@accton.com.tw>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+ 
+/*#define DEBUG*/ 
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/leds.h>
+#include <linux/slab.h>
+
+extern int accton_i2c_cpld_read(unsigned short cpld_addr, u8 reg);
+extern int accton_i2c_cpld_write(unsigned short cpld_addr, u8 reg, u8 value);
+
+extern void led_classdev_unregister(struct led_classdev *led_cdev);
+extern int led_classdev_register(struct device *parent, struct led_classdev *led_cdev);
+extern void led_classdev_resume(struct led_classdev *led_cdev);
+extern void led_classdev_suspend(struct led_classdev *led_cdev);
+
+#define DRVNAME "as5512_54x_led"
+
+struct accton_as5512_54x_led_data {
+    struct platform_device *pdev;
+    struct mutex     update_lock;
+    char             valid;           /* != 0 if registers are valid */
+    unsigned long    last_updated;    /* In jiffies */
+    u8               reg_val[2];     /* Register value, 0 = LOC/DIAG/FAN LED
+                                                        1 = PSU1/PSU2 LED */
+};
+
+static struct accton_as5512_54x_led_data  *ledctl = NULL;
+
+/* LED related data
+ */
+#define LED_TYPE_PSU1_REG_MASK   0x03
+#define LED_MODE_PSU1_GREEN_MASK 0x02
+#define LED_MODE_PSU1_AMBER_MASK 0x01
+#define LED_MODE_PSU1_OFF_MASK   0x03
+#define LED_MODE_PSU1_AUTO_MASK  0x00
+
+#define LED_TYPE_PSU2_REG_MASK   0x0C
+#define LED_MODE_PSU2_GREEN_MASK 0x08
+#define LED_MODE_PSU2_AMBER_MASK 0x04
+#define LED_MODE_PSU2_OFF_MASK   0x0C
+#define LED_MODE_PSU2_AUTO_MASK  0x00
+
+#define LED_TYPE_DIAG_REG_MASK    0x0C
+#define LED_MODE_DIAG_GREEN_MASK  0x08
+#define LED_MODE_DIAG_AMBER_MASK  0x04
+#define LED_MODE_DIAG_OFF_MASK    0x0C
+
+#define LED_TYPE_FAN_REG_MASK     0x03
+#define LED_MODE_FAN_GREEN_MASK   0x02
+#define LED_MODE_FAN_AMBER_MASK   0x01
+#define LED_MODE_FAN_OFF_MASK     0x03
+#define LED_MODE_FAN_AUTO_MASK    0x00
+
+#define LED_TYPE_LOC_REG_MASK     0x30
+#define LED_MODE_LOC_ON_MASK      0x00
+#define LED_MODE_LOC_OFF_MASK     0x10
+#define LED_MODE_LOC_BLINK_MASK   0x20
+ 
+static const u8 led_reg[] = {
+    0xA,        /* LOC/DIAG/FAN LED*/
+    0xB,        /* PSU1/PSU2 LED */
+};
+
+enum led_type {
+    LED_TYPE_PSU1,
+    LED_TYPE_PSU2,
+    LED_TYPE_DIAG,
+    LED_TYPE_FAN,
+    LED_TYPE_LOC
+};
+
+enum led_light_mode {
+	LED_MODE_OFF = 0,
+	LED_MODE_GREEN,
+	LED_MODE_GREEN_BLINK,
+	LED_MODE_AMBER,
+	LED_MODE_AMBER_BLINK,
+	LED_MODE_RED,
+	LED_MODE_RED_BLINK,
+	LED_MODE_BLUE,
+	LED_MODE_BLUE_BLINK,
+	LED_MODE_AUTO,
+	LED_MODE_UNKNOWN
+};
+
+struct led_type_mode {
+    enum led_type type;
+    int  type_mask;
+    enum led_light_mode mode;
+    int  mode_mask;
+};
+
+static struct led_type_mode led_type_mode_data[] = {
+{LED_TYPE_PSU1, LED_TYPE_PSU1_REG_MASK, LED_MODE_GREEN, LED_MODE_PSU1_GREEN_MASK},
+{LED_TYPE_PSU1, LED_TYPE_PSU1_REG_MASK, LED_MODE_AMBER, LED_MODE_PSU1_AMBER_MASK},
+{LED_TYPE_PSU1, LED_TYPE_PSU1_REG_MASK, LED_MODE_AUTO,  LED_MODE_PSU1_AUTO_MASK},
+{LED_TYPE_PSU1, LED_TYPE_PSU1_REG_MASK, LED_MODE_OFF,   LED_MODE_PSU1_OFF_MASK},
+{LED_TYPE_PSU2, LED_TYPE_PSU2_REG_MASK, LED_MODE_GREEN, LED_MODE_PSU2_GREEN_MASK},
+{LED_TYPE_PSU2, LED_TYPE_PSU2_REG_MASK, LED_MODE_AMBER, LED_MODE_PSU2_AMBER_MASK},
+{LED_TYPE_PSU2, LED_TYPE_PSU2_REG_MASK, LED_MODE_AUTO,  LED_MODE_PSU2_AUTO_MASK},
+{LED_TYPE_PSU2, LED_TYPE_PSU2_REG_MASK, LED_MODE_OFF,   LED_MODE_PSU2_OFF_MASK},
+{LED_TYPE_FAN,  LED_TYPE_FAN_REG_MASK,  LED_MODE_GREEN, LED_MODE_FAN_GREEN_MASK},
+{LED_TYPE_FAN,  LED_TYPE_FAN_REG_MASK,  LED_MODE_AMBER, LED_MODE_FAN_AMBER_MASK},
+{LED_TYPE_FAN,  LED_TYPE_FAN_REG_MASK,  LED_MODE_AUTO,  LED_MODE_FAN_AUTO_MASK},
+{LED_TYPE_FAN,  LED_TYPE_FAN_REG_MASK,  LED_MODE_OFF,   LED_MODE_FAN_OFF_MASK},
+{LED_TYPE_DIAG, LED_TYPE_DIAG_REG_MASK, LED_MODE_GREEN, LED_MODE_DIAG_GREEN_MASK},
+{LED_TYPE_DIAG, LED_TYPE_DIAG_REG_MASK, LED_MODE_AMBER, LED_MODE_DIAG_AMBER_MASK},
+{LED_TYPE_DIAG, LED_TYPE_DIAG_REG_MASK, LED_MODE_OFF,   LED_MODE_DIAG_OFF_MASK},
+{LED_TYPE_LOC, 	LED_TYPE_LOC_REG_MASK, 	LED_MODE_AMBER,       LED_MODE_LOC_ON_MASK},
+{LED_TYPE_LOC, 	LED_TYPE_LOC_REG_MASK, 	LED_MODE_OFF,         LED_MODE_LOC_OFF_MASK},
+{LED_TYPE_LOC, 	LED_TYPE_LOC_REG_MASK, 	LED_MODE_AMBER_BLINK, LED_MODE_LOC_BLINK_MASK}
+};
+
+static int led_reg_val_to_light_mode(enum led_type type, u8 reg_val) {
+    int i;
+    
+    for (i = 0; i < ARRAY_SIZE(led_type_mode_data); i++) {
+
+        if (type != led_type_mode_data[i].type)
+            continue;
+            
+        if ((led_type_mode_data[i].type_mask & reg_val) == 
+             led_type_mode_data[i].mode_mask)
+        {
+            return led_type_mode_data[i].mode;
+        }
+    }
+    
+    return 0;
+}
+
+static u8 led_light_mode_to_reg_val(enum led_type type, 
+                                    enum led_light_mode mode, u8 reg_val) {
+    int i;
+                                      
+    for (i = 0; i < ARRAY_SIZE(led_type_mode_data); i++) {
+        if (type != led_type_mode_data[i].type)
+            continue;
+
+        if (mode != led_type_mode_data[i].mode)
+            continue;
+            
+        reg_val = led_type_mode_data[i].mode_mask | 
+                 (reg_val & (~led_type_mode_data[i].type_mask));
+    }
+    
+    return reg_val;
+}
+
+static int accton_as5512_54x_led_read_value(u8 reg)
+{
+    return accton_i2c_cpld_read(0x60, reg);
+}
+
+static int accton_as5512_54x_led_write_value(u8 reg, u8 value)
+{
+    return accton_i2c_cpld_write(0x60, reg, value);
+}
+
+static void accton_as5512_54x_led_update(void)
+{
+    mutex_lock(&ledctl->update_lock);
+
+    if (time_after(jiffies, ledctl->last_updated + HZ + HZ / 2)
+        || !ledctl->valid) {
+        int i;
+
+        dev_dbg(&ledctl->pdev->dev, "Starting accton_as5512_54x_led update\n");
+        
+        /* Update LED data
+         */
+        for (i = 0; i < ARRAY_SIZE(ledctl->reg_val); i++) {
+            int status = accton_as5512_54x_led_read_value(led_reg[i]);
+            
+            if (status < 0) {
+                ledctl->valid = 0;
+                dev_dbg(&ledctl->pdev->dev, "reg %d, err %d\n", led_reg[i], status);
+				goto exit;
+            }
+            else
+            {
+                ledctl->reg_val[i] = status;                                  
+            }
+        }
+        
+        ledctl->last_updated = jiffies;
+        ledctl->valid = 1;
+    }
+    
+exit:    
+    mutex_unlock(&ledctl->update_lock);
+}
+
+static void accton_as5512_54x_led_set(struct led_classdev *led_cdev,
+                                      enum led_brightness led_light_mode, 
+                                      u8 reg, enum led_type type)
+{
+    int reg_val;
+    
+    mutex_lock(&ledctl->update_lock);
+    
+    reg_val = accton_as5512_54x_led_read_value(reg);
+    
+    if (reg_val < 0) {
+        dev_dbg(&ledctl->pdev->dev, "reg %d, err %d\n", reg, reg_val);
+        goto exit;
+    }
+
+    reg_val = led_light_mode_to_reg_val(type, led_light_mode, reg_val);
+    accton_as5512_54x_led_write_value(reg, reg_val);
+    
+    /* to prevent the slow-update issue */
+    ledctl->valid = 0;
+
+exit:
+    mutex_unlock(&ledctl->update_lock);
+}
+
+static void accton_as5512_54x_led_psu_1_set(struct led_classdev *led_cdev,
+                                            enum led_brightness led_light_mode)
+{
+    accton_as5512_54x_led_set(led_cdev, led_light_mode, led_reg[1], LED_TYPE_PSU1);
+}
+
+static enum led_brightness accton_as5512_54x_led_psu_1_get(struct led_classdev *cdev)
+{
+    accton_as5512_54x_led_update();
+    return led_reg_val_to_light_mode(LED_TYPE_PSU1, ledctl->reg_val[1]);
+}
+
+static void accton_as5512_54x_led_psu_2_set(struct led_classdev *led_cdev,
+                                            enum led_brightness led_light_mode)
+{
+    accton_as5512_54x_led_set(led_cdev, led_light_mode, led_reg[1], LED_TYPE_PSU2);
+}
+
+static enum led_brightness accton_as5512_54x_led_psu_2_get(struct led_classdev *cdev)
+{
+    accton_as5512_54x_led_update();
+    return led_reg_val_to_light_mode(LED_TYPE_PSU2, ledctl->reg_val[1]);
+}
+
+static void accton_as5512_54x_led_fan_set(struct led_classdev *led_cdev,
+                                          enum led_brightness led_light_mode)
+{
+    accton_as5512_54x_led_set(led_cdev, led_light_mode, led_reg[0], LED_TYPE_FAN);
+}
+
+static enum led_brightness accton_as5512_54x_led_fan_get(struct led_classdev *cdev)
+{
+    accton_as5512_54x_led_update();
+    return led_reg_val_to_light_mode(LED_TYPE_FAN, ledctl->reg_val[0]);
+}
+
+static void accton_as5512_54x_led_diag_set(struct led_classdev *led_cdev,
+                                           enum led_brightness led_light_mode)
+{
+    accton_as5512_54x_led_set(led_cdev, led_light_mode, led_reg[0], LED_TYPE_DIAG);
+}
+
+static enum led_brightness accton_as5512_54x_led_diag_get(struct led_classdev *cdev)
+{
+    accton_as5512_54x_led_update();
+    return led_reg_val_to_light_mode(LED_TYPE_DIAG, ledctl->reg_val[0]);
+}
+
+static void accton_as5512_54x_led_loc_set(struct led_classdev *led_cdev,
+                                          enum led_brightness led_light_mode)
+{
+    accton_as5512_54x_led_set(led_cdev, led_light_mode, led_reg[0], LED_TYPE_LOC);
+}
+
+static enum led_brightness accton_as5512_54x_led_loc_get(struct led_classdev *cdev)
+{
+    accton_as5512_54x_led_update();
+    return led_reg_val_to_light_mode(LED_TYPE_LOC, ledctl->reg_val[0]);
+}
+
+static struct led_classdev accton_as5512_54x_leds[] = {
+    [LED_TYPE_PSU1] = {
+        .name             = "accton_as5512_54x_led::psu1",
+        .default_trigger = "unused",
+        .brightness_set     = accton_as5512_54x_led_psu_1_set,
+        .brightness_get  = accton_as5512_54x_led_psu_1_get,
+        .flags             = LED_CORE_SUSPENDRESUME,
+        .max_brightness  = LED_MODE_AUTO,
+    },
+    [LED_TYPE_PSU2] = {
+        .name             = "accton_as5512_54x_led::psu2",
+        .default_trigger = "unused",
+        .brightness_set     = accton_as5512_54x_led_psu_2_set,
+        .brightness_get  = accton_as5512_54x_led_psu_2_get,
+        .flags             = LED_CORE_SUSPENDRESUME,
+        .max_brightness  = LED_MODE_AUTO,
+    },
+    [LED_TYPE_FAN] = {
+        .name             = "accton_as5512_54x_led::fan",
+        .default_trigger = "unused",
+        .brightness_set     = accton_as5512_54x_led_fan_set,
+        .brightness_get  = accton_as5512_54x_led_fan_get,
+        .flags             = LED_CORE_SUSPENDRESUME,
+        .max_brightness  = LED_MODE_AUTO,
+    },
+    [LED_TYPE_DIAG] = {
+        .name             = "accton_as5512_54x_led::diag",
+        .default_trigger = "unused",
+        .brightness_set     = accton_as5512_54x_led_diag_set,
+        .brightness_get  = accton_as5512_54x_led_diag_get,
+        .flags             = LED_CORE_SUSPENDRESUME,
+        .max_brightness  = LED_MODE_AUTO,
+    },
+    [LED_TYPE_LOC] = {
+        .name             = "accton_as5512_54x_led::loc",
+        .default_trigger = "unused",
+        .brightness_set     = accton_as5512_54x_led_loc_set,
+        .brightness_get  = accton_as5512_54x_led_loc_get,
+        .flags             = LED_CORE_SUSPENDRESUME,
+        .max_brightness  = LED_MODE_AUTO,
+    },
+};
+
+static int accton_as5512_54x_led_suspend(struct platform_device *dev,
+        pm_message_t state)
+{
+    int i = 0;
+    
+    for (i = 0; i < ARRAY_SIZE(accton_as5512_54x_leds); i++) {
+        led_classdev_suspend(&accton_as5512_54x_leds[i]);
+    }
+
+    return 0;
+}
+
+static int accton_as5512_54x_led_resume(struct platform_device *dev)
+{
+    int i = 0;
+    
+    for (i = 0; i < ARRAY_SIZE(accton_as5512_54x_leds); i++) {
+        led_classdev_resume(&accton_as5512_54x_leds[i]);
+    }
+
+    return 0;
+}
+
+static int accton_as5512_54x_led_probe(struct platform_device *pdev)
+{
+    int ret, i;
+    
+    for (i = 0; i < ARRAY_SIZE(accton_as5512_54x_leds); i++) {
+        ret = led_classdev_register(&pdev->dev, &accton_as5512_54x_leds[i]);
+        
+        if (ret < 0)
+            break;
+    }
+    
+    /* Check if all LEDs were successfully registered */
+    if (i != ARRAY_SIZE(accton_as5512_54x_leds)){
+        int j;
+        
+        /* only unregister the LEDs that were successfully registered */
+        for (j = 0; j < i; j++) {
+            led_classdev_unregister(&accton_as5512_54x_leds[i]);
+        }
+    }
+
+    return ret;
+}
+
+static int accton_as5512_54x_led_remove(struct platform_device *pdev)
+{
+    int i;
+
+    for (i = 0; i < ARRAY_SIZE(accton_as5512_54x_leds); i++) {
+        led_classdev_unregister(&accton_as5512_54x_leds[i]);
+    }
+
+    return 0;
+}
+
+static struct platform_driver accton_as5512_54x_led_driver = {
+    .probe      = accton_as5512_54x_led_probe,
+    .remove     = accton_as5512_54x_led_remove,
+    .suspend    = accton_as5512_54x_led_suspend,
+    .resume     = accton_as5512_54x_led_resume,
+    .driver     = {
+    .name   = DRVNAME,
+    .owner  = THIS_MODULE,
+    },
+};
+
+static int __init accton_as5512_54x_led_init(void)
+{
+    int ret;
+
+    extern int platform_accton_as5512_54x(void);
+    if(!platform_accton_as5512_54x()) {
+        return -ENODEV;
+    }
+
+    ret = platform_driver_register(&accton_as5512_54x_led_driver);
+    if (ret < 0) {
+        goto exit;
+    }
+        
+    ledctl = kzalloc(sizeof(struct accton_as5512_54x_led_data), GFP_KERNEL);
+    if (!ledctl) {
+        ret = -ENOMEM;
+        platform_driver_unregister(&accton_as5512_54x_led_driver);
+        goto exit;
+    }
+
+    mutex_init(&ledctl->update_lock);
+    
+    ledctl->pdev = platform_device_register_simple(DRVNAME, -1, NULL, 0);
+    if (IS_ERR(ledctl->pdev)) {
+        ret = PTR_ERR(ledctl->pdev);
+        platform_driver_unregister(&accton_as5512_54x_led_driver);
+        kfree(ledctl);
+        goto exit;
+    }
+
+exit:
+    return ret;
+}
+
+static void __exit accton_as5512_54x_led_exit(void)
+{
+    platform_device_unregister(ledctl->pdev);
+    platform_driver_unregister(&accton_as5512_54x_led_driver);
+    kfree(ledctl);
+}
+
+module_init(accton_as5512_54x_led_init);
+module_exit(accton_as5512_54x_led_exit);
+
+MODULE_AUTHOR("Brandon Chuang <brandon_chuang@accton.com.tw>");
+MODULE_DESCRIPTION("accton_as5512_54x_led driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/misc/eeprom/Kconfig b/drivers/misc/eeprom/Kconfig
index c75227b..d90ebe2 100644
--- a/drivers/misc/eeprom/Kconfig
+++ b/drivers/misc/eeprom/Kconfig
@@ -135,7 +135,16 @@ config EEPROM_ACCTON_AS5812_54t_SFP
 
 	  This driver can also be built as a module. If so, the module will
 	  be called accton_as5812_54t_sfp.
-		  
+
+config EEPROM_ACCTON_AS5512_54X_SFP
+        tristate "Accton as5512_54x sfp"
+        depends on I2C && SENSORS_ACCTON_I2C_CPLD
+        help
+          If you say yes here you get support for Accton 5512_54x sfp.
+
+          This driver can also be built as a module. If so, the module will
+          be called accton_5512_54x_sfp.
+
 config EEPROM_93CX6
 	tristate "EEPROM 93CX6 support"
 	help
diff --git a/drivers/misc/eeprom/Makefile b/drivers/misc/eeprom/Makefile
index 152a8bc..907f836 100644
--- a/drivers/misc/eeprom/Makefile
+++ b/drivers/misc/eeprom/Makefile
@@ -13,4 +13,5 @@ obj-$(CONFIG_EEPROM_ACCTON_AS7712_32x_SFP) += accton_as7712_32x_sfp.o
 obj-$(CONFIG_EEPROM_ACCTON_AS5812_54x_SFP) += accton_as5812_54x_sfp.o
 obj-$(CONFIG_EEPROM_ACCTON_AS6812_32x_SFP) += accton_as6812_32x_sfp.o
 obj-$(CONFIG_EEPROM_ACCTON_AS5812_54t_SFP) += accton_as5812_54t_sfp.o
+obj-$(CONFIG_EEPROM_ACCTON_AS5512_54X_SFP) += accton_as5512_54x_sfp.o
 obj-$(CONFIG_EEPROM_SFF_8436) += sff_8436_eeprom.o
diff --git a/drivers/misc/eeprom/accton_as5512_54x_sfp.c b/drivers/misc/eeprom/accton_as5512_54x_sfp.c
new file mode 100644
index 0000000..d89e71d
--- /dev/null
+++ b/drivers/misc/eeprom/accton_as5512_54x_sfp.c
@@ -0,0 +1,1237 @@
+/*
+ * SFP driver for accton as5512_54x sfp
+ *
+ * Copyright (C)  Brandon Chuang <brandon_chuang@accton.com.tw>
+ *
+ * Based on ad7414.c
+ * Copyright 2006 Stefan Roese <sr at denx.de>, DENX Software Engineering
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/sysfs.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+
+#define DRIVER_NAME 	"as5512_54x_sfp"
+
+#define DEBUG_MODE 0
+
+#if (DEBUG_MODE == 1)
+	#define DEBUG_PRINT(fmt, args...)                                        \
+		printk (KERN_INFO "%s:%s[%d]: " fmt "\r\n", __FILE__, __FUNCTION__, __LINE__, ##args)
+#else
+	#define DEBUG_PRINT(fmt, args...)
+#endif
+
+#define NUM_OF_SFP_PORT 		54
+#define EEPROM_NAME 			"sfp_eeprom"
+#define EEPROM_SIZE				256	/*  256 byte eeprom */
+#define BIT_INDEX(i) 			(1ULL << (i))
+#define USE_I2C_BLOCK_READ 		1
+#define I2C_RW_RETRY_COUNT		3
+#define I2C_RW_RETRY_INTERVAL	100 /* ms */
+
+#define SFP_EEPROM_A0_I2C_ADDR (0xA0 >> 1)
+#define SFP_EEPROM_A2_I2C_ADDR (0xA2 >> 1)
+
+#define SFF8024_PHYSICAL_DEVICE_ID_ADDR		0x0
+#define SFF8024_DEVICE_ID_SFP				0x3
+#define SFF8024_DEVICE_ID_QSFP				0xC
+#define SFF8024_DEVICE_ID_QSFP_PLUS			0xD
+#define SFF8024_DEVICE_ID_QSFP28			0x11
+
+#define SFF8472_DIAG_MON_TYPE_ADDR        	92
+#define SFF8472_DIAG_MON_TYPE_DDM_MASK		0x40
+#define SFF8472_10G_ETH_COMPLIANCE_ADDR		0x3
+#define SFF8472_10G_BASE_MASK				0xF0
+
+#define SFF8436_RX_LOS_ADDR					3
+#define SFF8436_TX_FAULT_ADDR				4
+#define SFF8436_TX_DISABLE_ADDR				86
+
+static ssize_t sfp_eeprom_read(struct i2c_client *, u8, u8 *,int);
+static ssize_t sfp_eeprom_write(struct i2c_client *, u8 , const char *,int);
+extern int accton_i2c_cpld_read(unsigned short cpld_addr, u8 reg);
+extern int accton_i2c_cpld_write(unsigned short cpld_addr, u8 reg, u8 value);
+
+/* Addresses scanned
+ */
+static const unsigned short normal_i2c[] = { SFP_EEPROM_A0_I2C_ADDR, SFP_EEPROM_A2_I2C_ADDR, I2C_CLIENT_END };
+
+#define CPLD_PORT_TO_FRONT_PORT(port)  (port+1)
+
+enum port_numbers {
+sfp1,  sfp2,  sfp3,  sfp4,  sfp5,  sfp6,  sfp7,  sfp8, 
+sfp9,  sfp10, sfp11, sfp12, sfp13, sfp14, sfp15, sfp16,
+sfp17, sfp18, sfp19, sfp20, sfp21, sfp22, sfp23, sfp24,
+sfp25, sfp26, sfp27, sfp28, sfp29, sfp30, sfp31, sfp32,
+sfp33, sfp34, sfp35, sfp36, sfp37, sfp38, sfp39, sfp40,
+sfp41, sfp42, sfp43, sfp44, sfp45, sfp46, sfp47, sfp48,
+sfp49, sfp50, sfp51, sfp52, sfp53, sfp54
+};
+
+static const struct i2c_device_id sfp_device_id[] = {
+{ "sfp1",  sfp1 },  { "sfp2",  sfp2 },  { "sfp3",  sfp3 },  { "sfp4",  sfp4 },
+{ "sfp5",  sfp5 },  { "sfp6",  sfp6 },  { "sfp7",  sfp7 },  { "sfp8",  sfp8 },
+{ "sfp9",  sfp9 },  { "sfp10", sfp10 }, { "sfp11", sfp11 }, { "sfp12", sfp12 },
+{ "sfp13", sfp13 }, { "sfp14", sfp14 }, { "sfp15", sfp15 }, { "sfp16", sfp16 },
+{ "sfp17", sfp17 }, { "sfp18", sfp18 }, { "sfp19", sfp19 }, { "sfp20", sfp20 },
+{ "sfp21", sfp21 }, { "sfp22", sfp22 }, { "sfp23", sfp23 }, { "sfp24", sfp24 },
+{ "sfp25", sfp25 }, { "sfp26", sfp26 }, { "sfp27", sfp27 }, { "sfp28", sfp28 },
+{ "sfp29", sfp29 }, { "sfp30", sfp30 }, { "sfp31", sfp31 }, { "sfp32", sfp32 },
+{ "sfp33", sfp33 }, { "sfp34", sfp34 }, { "sfp35", sfp35 }, { "sfp36", sfp36 },
+{ "sfp37", sfp37 }, { "sfp38", sfp38 }, { "sfp39", sfp39 }, { "sfp40", sfp40 },
+{ "sfp41", sfp41 }, { "sfp42", sfp42 }, { "sfp43", sfp43 }, { "sfp44", sfp44 },
+{ "sfp45", sfp45 }, { "sfp46", sfp46 }, { "sfp47", sfp47 }, { "sfp48", sfp48 },
+{ "sfp49", sfp49 }, { "sfp50", sfp50 }, { "sfp51", sfp51 }, { "sfp52", sfp52 },
+{ "sfp53", sfp53 }, { "sfp54", sfp54 },
+{ /* LIST END */ }
+};
+MODULE_DEVICE_TABLE(i2c, sfp_device_id);
+
+/* 
+ * list of valid port types
+ * note OOM_PORT_TYPE_NOT_PRESENT to indicate no 
+ * module is present in this port
+ */
+typedef enum oom_driver_port_type_e {
+	OOM_DRIVER_PORT_TYPE_INVALID,
+	OOM_DRIVER_PORT_TYPE_NOT_PRESENT,
+	OOM_DRIVER_PORT_TYPE_SFP,
+	OOM_DRIVER_PORT_TYPE_SFP_PLUS,
+	OOM_DRIVER_PORT_TYPE_QSFP,
+	OOM_DRIVER_PORT_TYPE_QSFP_PLUS,
+	OOM_DRIVER_PORT_TYPE_QSFP28
+} oom_driver_port_type_t;
+
+enum driver_type_e {
+	DRIVER_TYPE_SFP_MSA,
+	DRIVER_TYPE_SFP_DDM,
+	DRIVER_TYPE_QSFP
+};
+
+/* Each client has this additional data
+ */
+struct eeprom_data {
+	char				 valid;			/* !=0 if registers are valid */
+	unsigned long		 last_updated;	/* In jiffies */
+	struct bin_attribute bin;			/* eeprom data */		
+};
+
+struct sfp_msa_data {
+	char			valid;		  	/* !=0 if registers are valid */
+	unsigned long	last_updated;   /* In jiffies */
+	u64				status[6];	  	/* bit0:port0, bit1:port1 and so on */
+									/* index 0 => tx_fail
+											 1 => tx_disable
+											 2 => rx_loss 
+											 3 => device id
+											 4 => 10G Ethernet Compliance Codes 
+												  to distinguish SFP or SFP+ 
+											 5 => DIAGNOSTIC MONITORING TYPE */
+	struct eeprom_data				eeprom;
+};
+
+struct sfp_ddm_data {
+	struct eeprom_data				eeprom;
+};
+
+struct qsfp_data {
+	char			valid;		  	/* !=0 if registers are valid */
+	unsigned long	last_updated;   /* In jiffies */
+	u8				status[3];	  	/* bit0:port0, bit1:port1 and so on */
+									/* index 0 => tx_fail
+											 1 => tx_disable
+											 2 => rx_loss */
+
+	u8					device_id;	
+	struct eeprom_data	eeprom;
+};
+
+struct sfp_port_data {
+	struct mutex		   update_lock;
+	enum driver_type_e     driver_type;
+	int 				   port;		/* CPLD port index */
+	oom_driver_port_type_t port_type;
+	u64					   present;		/* present status, bit0:port0, bit1:port1 and so on */
+
+	struct sfp_msa_data	  *msa;
+	struct sfp_ddm_data   *ddm;
+	struct qsfp_data 	  *qsfp;
+
+	struct i2c_client 	  *client;
+};
+
+enum sfp_sysfs_attributes {
+	PRESENT,
+	PRESENT_ALL,
+	PORT_NUMBER,
+	PORT_TYPE,
+	DDM_IMPLEMENTED,
+	TX_FAULT,
+	TX_FAULT1,
+	TX_FAULT2,
+	TX_FAULT3,
+	TX_FAULT4,
+	TX_DISABLE,
+	TX_DISABLE1,
+	TX_DISABLE2,
+	TX_DISABLE3,
+	TX_DISABLE4,
+	RX_LOS,
+	RX_LOS1,
+	RX_LOS2,
+	RX_LOS3,
+	RX_LOS4,
+	RX_LOS_ALL
+};
+
+static ssize_t show_port_number(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct sfp_port_data *data = i2c_get_clientdata(client);
+	return sprintf(buf, "%d\n", CPLD_PORT_TO_FRONT_PORT(data->port));
+}
+
+static struct sfp_port_data* sfp_update_present(struct i2c_client *client)
+{
+	int i = 0, j = 0, status = -1;
+	u8 reg;
+	unsigned short cpld_addr;
+	struct sfp_port_data *data = i2c_get_clientdata(client);
+
+	DEBUG_PRINT("Starting sfp present status update");
+	mutex_lock(&data->update_lock);
+	data->present = 0;
+
+	/* Read present status of port 1~48(SFP port) */
+	for (i = 0; i < 2; i++) {
+		for (j = 0; j < 3; j++) {
+			cpld_addr 	= 0x61+i;
+			reg	   		= 0x6+j;
+			status		= accton_i2c_cpld_read(cpld_addr, reg);
+
+			if (unlikely(status < 0)) {
+				data = ERR_PTR(status);
+				dev_dbg(&client->dev, "cpld(0x%x) reg(0x%x) err %d\n", cpld_addr, reg, status);
+				goto exit;
+			}
+
+			DEBUG_PRINT("Present status = 0x%lx\r\n", data->present);		
+			data->present |= (u64)status << ((i*24) + (j%3)*8);
+		}
+	}
+
+	/* Read present status of port 49-54(QSFP port) */
+	cpld_addr = 0x62;
+	reg 	  = 0x14;
+	status 	  = accton_i2c_cpld_read(cpld_addr, reg);
+
+	if (unlikely(status < 0)) {
+		data = ERR_PTR(status);
+		dev_dbg(&client->dev, "cpld(0x%x) reg(0x%x) err %d\n", cpld_addr, reg, status);
+		goto exit;
+	}
+	else {
+		data->present |= (u64)status << 48;
+	}	
+
+	DEBUG_PRINT("Present status = 0x%lx", data->present);
+exit:
+	mutex_unlock(&data->update_lock);
+	return data;
+}
+
+static struct sfp_port_data* sfp_update_tx_rx_status(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct sfp_port_data *data = i2c_get_clientdata(client);
+	int i = 0, j = 0;
+	int status = -1;
+
+	if (time_before(jiffies, data->msa->last_updated + HZ + HZ / 2) && data->msa->valid) {
+		return data;
+	}
+
+	DEBUG_PRINT("Starting as5512_54x sfp tx rx status update");
+	mutex_lock(&data->update_lock);
+	data->msa->valid = 0;
+	memset(data->msa->status, 0, sizeof(data->msa->status));
+
+	/* Read status of port 1~48(SFP port) */
+	for (i = 0; i < 2; i++) {
+		for (j = 0; j < 9; j++) {
+			u8 reg;
+			unsigned short cpld_addr;
+			reg 	  = 0x9+j;
+			cpld_addr = 0x61+i;
+			
+			status	= accton_i2c_cpld_read(cpld_addr, reg);
+			if (unlikely(status < 0)) {
+				data = ERR_PTR(status);
+				dev_dbg(&client->dev, "cpld(0x%x) reg(0x%x) err %d\n", cpld_addr, reg, status);
+				goto exit;
+			}
+
+			data->msa->status[j/3] |= (u64)status << ((i*24) + (j%3)*8);
+		}
+	}
+
+	data->msa->valid = 1;
+	data->msa->last_updated = jiffies;
+
+exit:
+	mutex_unlock(&data->update_lock);
+	return data;
+}
+
+static ssize_t sfp_set_tx_disable(struct device *dev, struct device_attribute *da,
+			const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct sfp_port_data *data = i2c_get_clientdata(client);
+	unsigned short cpld_addr = 0;
+	u8 cpld_reg = 0, cpld_val = 0, cpld_bit = 0;
+	long disable;
+	int error;
+
+	error = kstrtol(buf, 10, &disable);
+	if (error) {
+		return error;
+	}
+
+	mutex_lock(&data->update_lock);
+
+	if(data->port < 24) {
+		cpld_addr = 0x61;
+		cpld_reg  = 0xC + data->port / 8;
+		cpld_bit  = 1 << (data->port % 8);
+	}
+	else { /* port 24 ~ 48 */
+		cpld_addr = 0x62;
+		cpld_reg  = 0xC + (data->port - 24) / 8;
+		cpld_bit  = 1 << (data->port % 8);
+	}
+
+	/* Read current status */
+	cpld_val = accton_i2c_cpld_read(cpld_addr, cpld_reg);
+
+	/* Update tx_disable status */
+	if (disable) {
+		data->msa->status[1] |= BIT_INDEX(data->port);
+		cpld_val |= cpld_bit;
+	}
+	else {
+		data->msa->status[1] &= ~BIT_INDEX(data->port);
+		cpld_val &= ~cpld_bit;
+	}
+
+	accton_i2c_cpld_write(cpld_addr, cpld_reg, cpld_val);
+	mutex_unlock(&data->update_lock);
+	return count;
+}
+
+static int sfp_is_port_present(struct i2c_client *client, int port)
+{
+	struct sfp_port_data *data = i2c_get_clientdata(client);
+
+	data = sfp_update_present(client);
+	if (IS_ERR(data)) {
+		return PTR_ERR(data);
+	}
+
+	return (data->present & BIT_INDEX(data->port)) ? 0 : 1;
+}
+
+static ssize_t show_present(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);
+
+	if (PRESENT_ALL == attr->index) {
+		int i;
+		u8 values[7]  = {0};
+		struct sfp_port_data *data = sfp_update_present(client);
+		
+		if (IS_ERR(data)) {
+			return PTR_ERR(data);
+		}
+
+		for (i = 0; i < ARRAY_SIZE(values); i++) {
+			values[i] = ~(u8)(data->present >> (i * 8));
+		}
+
+        /* Return values 1 -> 54 in order */
+        return sprintf(buf, "%.2x %.2x %.2x %.2x %.2x %.2x %.2x\n",
+                       values[0], values[1], values[2],
+                       values[3], values[4], values[5],
+                       values[6] & 0x3F);
+	}
+	else {
+		struct sfp_port_data *data = i2c_get_clientdata(client);
+		int present = sfp_is_port_present(client, data->port);
+
+		if (IS_ERR_VALUE(present)) {
+			return present;
+		}
+
+		/* PRESENT */
+		return sprintf(buf, "%d\n", present);
+	}
+}
+
+static struct sfp_port_data *sfp_update_port_type(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct sfp_port_data *data = i2c_get_clientdata(client);
+	u8 buf = 0;
+	int status;
+
+	mutex_lock(&data->update_lock);
+
+	switch (data->driver_type) {
+		case DRIVER_TYPE_SFP_MSA:
+		{
+			status = sfp_eeprom_read(client, SFF8024_PHYSICAL_DEVICE_ID_ADDR, &buf, sizeof(buf));	
+			if (unlikely(status < 0)) {
+				data->port_type = OOM_DRIVER_PORT_TYPE_INVALID;
+				break;
+			}
+
+			if (buf != SFF8024_DEVICE_ID_SFP) {
+				data->port_type = OOM_DRIVER_PORT_TYPE_INVALID;
+				break;
+			}
+			
+			status = sfp_eeprom_read(client, SFF8472_10G_ETH_COMPLIANCE_ADDR, &buf, sizeof(buf));	
+			if (unlikely(status < 0)) {
+				data->port_type = OOM_DRIVER_PORT_TYPE_INVALID;
+				break;
+			}
+
+			DEBUG_PRINT("sfp port type (0x3) data = (0x%x)", buf);
+			data->port_type = buf & SFF8472_10G_BASE_MASK ? OOM_DRIVER_PORT_TYPE_SFP_PLUS : OOM_DRIVER_PORT_TYPE_SFP;
+			break;
+		}
+		case DRIVER_TYPE_QSFP:
+		{
+			status = sfp_eeprom_read(client, SFF8024_PHYSICAL_DEVICE_ID_ADDR, &buf, sizeof(buf));	
+			if (unlikely(status < 0)) {
+				data->port_type = OOM_DRIVER_PORT_TYPE_INVALID;
+				break;
+			}
+
+			DEBUG_PRINT("qsfp port type (0x0) buf = (0x%x)", buf);
+			switch (buf) {
+			case SFF8024_DEVICE_ID_QSFP:
+				data->port_type = OOM_DRIVER_PORT_TYPE_QSFP;
+				break;
+			case SFF8024_DEVICE_ID_QSFP_PLUS:
+				data->port_type = OOM_DRIVER_PORT_TYPE_QSFP_PLUS;
+				break;
+			case SFF8024_DEVICE_ID_QSFP28:
+				data->port_type = OOM_DRIVER_PORT_TYPE_QSFP_PLUS;
+				break;				
+			default:
+				data->port_type = OOM_DRIVER_PORT_TYPE_INVALID;
+				break;
+			}
+
+			break;
+		}
+		default:
+			break;
+	}
+
+	mutex_unlock(&data->update_lock);
+	return data;
+}
+
+static ssize_t show_port_type(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct sfp_port_data *data = i2c_get_clientdata(client);	
+	int present = sfp_is_port_present(client, data->port);
+
+	if (IS_ERR_VALUE(present)) {
+		return present;
+	}
+
+	if (!present) {
+		return sprintf(buf, "%d\n", OOM_DRIVER_PORT_TYPE_NOT_PRESENT);
+	}
+
+	sfp_update_port_type(dev);
+	return sprintf(buf, "%d\n", data->port_type);
+}
+
+static struct sfp_port_data* qsfp_update_tx_rx_status(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct sfp_port_data *data = i2c_get_clientdata(client);	
+	int i, status = -1;
+	u8 buf = 0;
+	u8 reg[] = {SFF8436_TX_FAULT_ADDR, SFF8436_TX_DISABLE_ADDR, SFF8436_RX_LOS_ADDR};
+
+	if (time_before(jiffies, data->qsfp->last_updated + HZ + HZ / 2) && data->qsfp->valid) {
+		return data;
+	}
+
+	DEBUG_PRINT("Starting sfp tx rx status update");
+	mutex_lock(&data->update_lock);
+	data->qsfp->valid = 0;
+	memset(data->qsfp->status, 0, sizeof(data->qsfp->status));
+
+	/* Notify device to update tx fault/ tx disable/ rx los status */
+	for (i = 0; i < ARRAY_SIZE(reg); i++) {
+		status = sfp_eeprom_read(client, reg[i], &buf, sizeof(buf)); 
+		if (unlikely(status < 0)) {
+			data = ERR_PTR(status);
+			goto exit;
+		}		
+	}
+	msleep(200);
+
+	/* Read actual tx fault/ tx disable/ rx los status */
+	for (i = 0; i < ARRAY_SIZE(reg); i++) {
+		status = sfp_eeprom_read(client, reg[i], &buf, sizeof(buf)); 
+		if (unlikely(status < 0)) {
+			data = ERR_PTR(status);
+			goto exit;
+		}
+
+		DEBUG_PRINT("qsfp reg(0x%x) status = (0x%x)", reg[i], data->qsfp->status[i]);
+		data->qsfp->status[i] = (buf & 0xF);
+	}
+
+	data->qsfp->valid = 1;
+	data->qsfp->last_updated = jiffies;
+
+exit:
+	mutex_unlock(&data->update_lock);
+	return data;	
+}
+
+static ssize_t qsfp_show_tx_rx_status(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	int status;
+	u8 val = 0;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct i2c_client *client = to_i2c_client(dev);	
+	struct sfp_port_data *data = i2c_get_clientdata(client);	
+
+	status = sfp_is_port_present(client, data->port);
+	if (IS_ERR_VALUE(status)) {
+		return status;
+	}
+
+	data = qsfp_update_tx_rx_status(dev);
+	if (IS_ERR(data)) {
+		return PTR_ERR(data);
+	}
+
+	switch (attr->index) {
+	case TX_FAULT1:
+	case TX_FAULT2:	
+	case TX_FAULT3:	
+	case TX_FAULT4:	
+		val = (data->qsfp->status[2] & BIT_INDEX(attr->index - TX_FAULT1)) ? 1 : 0;
+		break;
+	case TX_DISABLE1:
+	case TX_DISABLE2:
+	case TX_DISABLE3:
+	case TX_DISABLE4:
+		val = (data->qsfp->status[1] & BIT_INDEX(attr->index - TX_DISABLE1)) ? 1 : 0;
+		break;
+	case RX_LOS1:
+	case RX_LOS2:
+	case RX_LOS3:
+	case RX_LOS4:
+		val = (data->qsfp->status[0] & BIT_INDEX(attr->index - RX_LOS1)) ? 1 : 0;
+		break;		
+	default:
+		break;
+	}
+
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t qsfp_set_tx_disable(struct device *dev, struct device_attribute *da,
+			const char *buf, size_t count)
+{
+	long disable;
+	int status;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct sfp_port_data *data = NULL;
+
+	status = kstrtol(buf, 10, &disable);
+	if (status) {
+		return status;
+	}
+
+	data = qsfp_update_tx_rx_status(dev);
+	if (IS_ERR(data)) {
+		return PTR_ERR(data);
+	}
+
+	mutex_lock(&data->update_lock);
+
+	if (disable) {
+		data->qsfp->status[1] |= (1 << (attr->index - TX_DISABLE1));
+	}
+	else {
+		data->qsfp->status[1] &= ~(1 << (attr->index - TX_DISABLE1));
+	}
+
+	DEBUG_PRINT("index = (%d), status = (0x%x)", attr->index, data->qsfp->status[1]);
+	status = sfp_eeprom_write(data->client, SFF8436_TX_DISABLE_ADDR, &data->qsfp->status[1], sizeof(data->qsfp->status[1]));
+	if (unlikely(status < 0)) {
+		count = status;
+	}
+
+	mutex_unlock(&data->update_lock);
+	return count;
+}
+
+static ssize_t sfp_show_ddm_implemented(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	int status;
+	char ddm;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct sfp_port_data *data = i2c_get_clientdata(client);	
+
+	status = sfp_is_port_present(client, data->port);
+	if (IS_ERR_VALUE(status)) {
+		return status;
+	}
+
+	status = sfp_eeprom_read(client, SFF8472_DIAG_MON_TYPE_ADDR, &ddm, sizeof(ddm));	
+	if (unlikely(status < 0)) {
+		return status;
+	}
+
+	return sprintf(buf, "%d\n", (ddm & SFF8472_DIAG_MON_TYPE_DDM_MASK) ? 1 : 0);
+}
+
+static ssize_t sfp_show_tx_rx_status(struct device *dev, struct device_attribute *da,
+			 char *buf)
+{
+	u8 val = 0, index = 0;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(da);
+	struct sfp_port_data *data = sfp_update_tx_rx_status(dev);
+
+	if (IS_ERR(data)) {
+		return PTR_ERR(data);
+	}
+
+	if(attr->index == RX_LOS_ALL) {
+		int i = 0;
+		u8 values[6] = {0};
+
+		for (i = 0; i < ARRAY_SIZE(values); i++) {
+			values[i] = (u8)(data->msa->status[2] >> (i * 8));
+		}
+		
+		/** Return values 1 -> 48 in order */
+		return sprintf(buf, "%.2x %.2x %.2x %.2x %.2x %.2x\n",
+						values[0], values[1], values[2],
+						values[3], values[4], values[5]);	
+	}
+	
+	switch (attr->index) {
+	case TX_FAULT:
+		index = 0;
+		break;
+	case TX_DISABLE:
+		index = 1;
+		break;
+	case RX_LOS:
+		index = 2;
+		break;		
+	default:
+		break;
+	}
+
+	val = (data->msa->status[index] & BIT_INDEX(data->port)) ? 1 : 0;
+	return sprintf(buf, "%d\n", val);
+}
+
+/* SFP/QSFP common attributes for sysfs */
+static SENSOR_DEVICE_ATTR(sfp_port_number, S_IRUGO, show_port_number, NULL, PORT_NUMBER);
+static SENSOR_DEVICE_ATTR(sfp_port_type, S_IRUGO, show_port_type, NULL, PORT_TYPE);
+static SENSOR_DEVICE_ATTR(sfp_is_present,  S_IRUGO, show_present, NULL, PRESENT);
+static SENSOR_DEVICE_ATTR(sfp_is_present_all,  S_IRUGO, show_present, NULL, PRESENT_ALL);
+
+/* QSFP attributes for sysfs */
+static SENSOR_DEVICE_ATTR(sfp_rx_los1, S_IRUGO, qsfp_show_tx_rx_status, NULL, RX_LOS1);
+static SENSOR_DEVICE_ATTR(sfp_rx_los2, S_IRUGO, qsfp_show_tx_rx_status, NULL, RX_LOS2);
+static SENSOR_DEVICE_ATTR(sfp_rx_los3, S_IRUGO, qsfp_show_tx_rx_status, NULL, RX_LOS3);
+static SENSOR_DEVICE_ATTR(sfp_rx_los4, S_IRUGO, qsfp_show_tx_rx_status, NULL, RX_LOS4);
+static SENSOR_DEVICE_ATTR(sfp_tx_disable1, S_IWUSR | S_IRUGO, qsfp_show_tx_rx_status, qsfp_set_tx_disable, TX_DISABLE1);
+static SENSOR_DEVICE_ATTR(sfp_tx_disable2, S_IWUSR | S_IRUGO, qsfp_show_tx_rx_status, qsfp_set_tx_disable, TX_DISABLE2);
+static SENSOR_DEVICE_ATTR(sfp_tx_disable3, S_IWUSR | S_IRUGO, qsfp_show_tx_rx_status, qsfp_set_tx_disable, TX_DISABLE3);
+static SENSOR_DEVICE_ATTR(sfp_tx_disable4, S_IWUSR | S_IRUGO, qsfp_show_tx_rx_status, qsfp_set_tx_disable, TX_DISABLE4);
+static SENSOR_DEVICE_ATTR(sfp_tx_fault1, S_IRUGO, qsfp_show_tx_rx_status, NULL, TX_FAULT1);
+static SENSOR_DEVICE_ATTR(sfp_tx_fault2, S_IRUGO, qsfp_show_tx_rx_status, NULL, TX_FAULT2);
+static SENSOR_DEVICE_ATTR(sfp_tx_fault3, S_IRUGO, qsfp_show_tx_rx_status, NULL, TX_FAULT3);
+static SENSOR_DEVICE_ATTR(sfp_tx_fault4, S_IRUGO, qsfp_show_tx_rx_status, NULL, TX_FAULT4);
+static struct attribute *qsfp_attributes[] = {
+	&sensor_dev_attr_sfp_port_number.dev_attr.attr,
+	&sensor_dev_attr_sfp_port_type.dev_attr.attr,
+	&sensor_dev_attr_sfp_is_present.dev_attr.attr,
+	&sensor_dev_attr_sfp_is_present_all.dev_attr.attr,
+	&sensor_dev_attr_sfp_rx_los1.dev_attr.attr,
+	&sensor_dev_attr_sfp_rx_los2.dev_attr.attr,
+	&sensor_dev_attr_sfp_rx_los3.dev_attr.attr,
+	&sensor_dev_attr_sfp_rx_los4.dev_attr.attr,
+	&sensor_dev_attr_sfp_tx_disable1.dev_attr.attr,
+	&sensor_dev_attr_sfp_tx_disable2.dev_attr.attr,
+	&sensor_dev_attr_sfp_tx_disable3.dev_attr.attr,
+	&sensor_dev_attr_sfp_tx_disable4.dev_attr.attr,
+	&sensor_dev_attr_sfp_tx_fault1.dev_attr.attr,
+	&sensor_dev_attr_sfp_tx_fault2.dev_attr.attr,
+	&sensor_dev_attr_sfp_tx_fault3.dev_attr.attr,
+	&sensor_dev_attr_sfp_tx_fault4.dev_attr.attr,	
+	NULL
+};
+
+/* SFP msa attributes for sysfs */
+static SENSOR_DEVICE_ATTR(sfp_ddm_implemented,   S_IRUGO, sfp_show_ddm_implemented, NULL, DDM_IMPLEMENTED);
+static SENSOR_DEVICE_ATTR(sfp_rx_los,  S_IRUGO, sfp_show_tx_rx_status, NULL, RX_LOS);
+static SENSOR_DEVICE_ATTR(sfp_rx_los_all,  S_IRUGO, sfp_show_tx_rx_status, NULL, RX_LOS_ALL);
+static SENSOR_DEVICE_ATTR(sfp_tx_disable,  S_IWUSR | S_IRUGO, sfp_show_tx_rx_status, sfp_set_tx_disable, TX_DISABLE);
+static SENSOR_DEVICE_ATTR(sfp_tx_fault,  S_IRUGO, sfp_show_tx_rx_status, NULL, TX_FAULT);
+static struct attribute *sfp_msa_attributes[] = {
+	&sensor_dev_attr_sfp_port_number.dev_attr.attr,
+	&sensor_dev_attr_sfp_port_type.dev_attr.attr,
+	&sensor_dev_attr_sfp_is_present.dev_attr.attr,
+	&sensor_dev_attr_sfp_is_present_all.dev_attr.attr,
+	&sensor_dev_attr_sfp_ddm_implemented.dev_attr.attr,
+	&sensor_dev_attr_sfp_tx_fault.dev_attr.attr,
+	&sensor_dev_attr_sfp_rx_los.dev_attr.attr,
+	&sensor_dev_attr_sfp_rx_los_all.dev_attr.attr,
+	&sensor_dev_attr_sfp_tx_disable.dev_attr.attr,
+	NULL
+};
+
+/* SFP ddm attributes for sysfs */
+static struct attribute *sfp_ddm_attributes[] = {
+	NULL
+};
+
+static ssize_t sfp_eeprom_write(struct i2c_client *client, u8 command, const char *data,
+			  int data_len)
+{
+#if USE_I2C_BLOCK_READ
+	int status, retry = I2C_RW_RETRY_COUNT;
+
+	if (data_len > I2C_SMBUS_BLOCK_MAX) {
+		data_len = I2C_SMBUS_BLOCK_MAX;
+	} 
+
+	while (retry) {
+		status = i2c_smbus_write_i2c_block_data(client, command, data_len, data);
+		if (unlikely(status < 0)) {
+			msleep(I2C_RW_RETRY_INTERVAL);
+			retry--;
+			continue;
+		}
+ 
+		break;
+	}
+
+	if (unlikely(status < 0)) {
+		return status;
+	}		
+
+	return data_len;
+#else
+	int status, retry = I2C_RW_RETRY_COUNT;
+
+	while (retry) {
+		status = i2c_smbus_write_byte_data(client, command, *data);
+		if (unlikely(status < 0)) {
+			msleep(I2C_RW_RETRY_INTERVAL);
+			retry--;
+			continue;
+		}
+ 
+		break;
+	}
+	
+	if (unlikely(status < 0)) {
+		return status;
+	}
+
+	return 1;
+#endif
+
+	
+}
+
+static ssize_t sfp_port_write(struct sfp_port_data *data, 
+						  const char *buf, loff_t off, size_t count)
+{
+	ssize_t retval = 0;
+	
+	if (unlikely(!count)) {
+		return count;
+	}
+	
+	/*
+	 * Write data to chip, protecting against concurrent updates
+	 * from this host, but not from other I2C masters.
+	 */
+	mutex_lock(&data->update_lock);
+	
+	while (count) {
+		ssize_t status;
+	
+		status = sfp_eeprom_write(data->client, off, buf, count);
+		if (status <= 0) {
+			if (retval == 0) {
+				retval = status;
+			}
+			break;
+		}
+		buf += status;
+		off += status;
+		count -= status;
+		retval += status;
+	}
+	
+	mutex_unlock(&data->update_lock);
+	return retval;
+}
+
+
+static ssize_t sfp_bin_write(struct file *filp, struct kobject *kobj,
+				struct bin_attribute *attr,
+				char *buf, loff_t off, size_t count)
+{
+	struct sfp_port_data *data;
+	DEBUG_PRINT("%s(%d) offset = (%d), count = (%d)", off, count);
+	data = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	return sfp_port_write(data, buf, off, count);
+}
+
+static ssize_t sfp_eeprom_read(struct i2c_client *client, u8 command, u8 *data,
+			  int data_len)
+{
+#if USE_I2C_BLOCK_READ
+	int status, retry = I2C_RW_RETRY_COUNT;
+
+	if (data_len > I2C_SMBUS_BLOCK_MAX) {
+		data_len = I2C_SMBUS_BLOCK_MAX;
+	}
+
+	while (retry) {
+		status = i2c_smbus_read_i2c_block_data(client, command, data_len, data);
+		if (unlikely(status < 0)) {
+			msleep(I2C_RW_RETRY_INTERVAL);
+			retry--;
+			continue;
+		}
+
+		break;
+	}
+	
+	if (unlikely(status < 0)) {
+		goto abort;
+	}
+	if (unlikely(status != data_len)) {
+		status = -EIO;
+		goto abort;
+	}
+	
+	//result = data_len;
+	
+abort:
+	return status;
+#else
+	int status, retry = I2C_RW_RETRY_COUNT;
+
+	while (retry) {
+		status = i2c_smbus_read_byte_data(client, command);
+		if (unlikely(status < 0)) {
+			msleep(I2C_RW_RETRY_INTERVAL);
+			retry--;
+			continue;
+		}
+ 
+		break;
+	}
+
+	if (unlikely(status < 0)) {
+		dev_dbg(&client->dev, "sfp read byte data failed, command(0x%2x), data(0x%2x)\r\n", command, result);
+		goto abort;
+	}
+
+	*data  = (u8)status;
+	status = 1;
+
+abort:
+	return status;	
+#endif
+}
+
+static ssize_t sfp_port_read(struct sfp_port_data *data,
+				char *buf, loff_t off, size_t count)
+{
+	ssize_t retval = 0;
+	
+	if (unlikely(!count)) {
+		DEBUG_PRINT("Count = 0, return");
+		return count;
+	}
+	
+	/*
+	 * Read data from chip, protecting against concurrent updates
+	 * from this host, but not from other I2C masters.
+	 */
+	mutex_lock(&data->update_lock);
+
+	while (count) {
+		ssize_t status;
+	
+		status = sfp_eeprom_read(data->client, off, buf, count);
+		if (status <= 0) {
+			if (retval == 0) {
+				retval = status;
+			}
+			break;
+		}
+		
+		buf += status;
+		off += status;
+		count -= status;
+		retval += status;
+	}
+	
+	mutex_unlock(&data->update_lock);
+	return retval;
+
+}
+
+static ssize_t sfp_bin_read(struct file *filp, struct kobject *kobj,
+		struct bin_attribute *attr,
+		char *buf, loff_t off, size_t count)
+{
+	struct sfp_port_data *data;
+	DEBUG_PRINT("offset = (%d), count = (%d)", off, count);
+	data = dev_get_drvdata(container_of(kobj, struct device, kobj));
+	return sfp_port_read(data, buf, off, count);
+}
+
+static int sfp_sysfs_eeprom_init(struct kobject *kobj, struct bin_attribute *eeprom)
+{
+	int err;
+
+	sysfs_bin_attr_init(eeprom);
+	eeprom->attr.name = EEPROM_NAME;
+	eeprom->attr.mode = S_IWUSR | S_IRUGO;
+	eeprom->read  	  = sfp_bin_read;
+	eeprom->write 	  = sfp_bin_write;
+	eeprom->size  	  = EEPROM_SIZE;	
+
+	/* Create eeprom file */
+	err = sysfs_create_bin_file(kobj, eeprom);
+	if (err) {
+		return err;
+	}
+	
+	return 0;
+}
+
+static int sfp_sysfs_eeprom_cleanup(struct kobject *kobj, struct bin_attribute *eeprom)
+{
+	sysfs_remove_bin_file(kobj, eeprom);
+	return 0;
+}
+
+static const struct attribute_group sfp_msa_group = {
+	.attrs = sfp_msa_attributes,
+};
+
+static int sfp_i2c_check_functionality(struct i2c_client *client)
+{
+#if USE_I2C_BLOCK_READ
+    return i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_I2C_BLOCK);
+#else
+    return i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA);
+#endif
+}
+
+static int sfp_msa_probe(struct i2c_client *client, const struct i2c_device_id *dev_id,
+							   struct sfp_msa_data **data)
+{
+	int status;
+	struct sfp_msa_data *msa;
+	
+	if (!sfp_i2c_check_functionality(client)) {
+        status = -EIO;
+        goto exit;		
+	}
+	
+	msa = kzalloc(sizeof(struct sfp_msa_data), GFP_KERNEL);
+	if (!msa) {
+		status = -ENOMEM;
+		goto exit;
+	}	
+	
+	/* Register sysfs hooks */
+	status = sysfs_create_group(&client->dev.kobj, &sfp_msa_group);
+	if (status) {
+		goto exit_free;
+	}
+
+	/* init eeprom */
+	status = sfp_sysfs_eeprom_init(&client->dev.kobj, &msa->eeprom.bin);
+	if (status) {
+		goto exit_remove;
+	}
+
+	*data = msa;
+	dev_info(&client->dev, "sfp msa '%s'\n", client->name);
+
+	return 0;
+
+exit_remove:
+	sysfs_remove_group(&client->dev.kobj, &sfp_msa_group);
+exit_free:
+	kfree(msa);
+exit:
+
+	return status;		
+}
+
+static const struct attribute_group sfp_ddm_group = {
+	.attrs = sfp_ddm_attributes,
+};
+
+static int sfp_ddm_probe(struct i2c_client *client, const struct i2c_device_id *dev_id,
+							   struct sfp_ddm_data **data)
+{
+	int status;
+	struct sfp_ddm_data *ddm;
+	
+	if (!sfp_i2c_check_functionality(client)) {
+        status = -EIO;
+        goto exit;		
+	}
+	
+	ddm = kzalloc(sizeof(struct sfp_ddm_data), GFP_KERNEL);
+	if (!ddm) {
+		status = -ENOMEM;
+		goto exit;
+	}	
+
+	/* Register sysfs hooks */
+	status = sysfs_create_group(&client->dev.kobj, &sfp_ddm_group);
+	if (status) {
+		goto exit_free;
+	}
+
+	/* init eeprom */
+	status = sfp_sysfs_eeprom_init(&client->dev.kobj, &ddm->eeprom.bin);
+	if (status) {
+		goto exit_remove;
+	}
+
+	*data = ddm;
+	dev_info(&client->dev, "sfp ddm '%s'\n", client->name);
+
+	return 0;
+
+exit_remove:
+	sysfs_remove_group(&client->dev.kobj, &sfp_ddm_group);
+exit_free:
+	kfree(ddm);
+exit:
+
+	return status;	
+}
+
+static const struct attribute_group qsfp_group = {
+	.attrs = qsfp_attributes,
+};
+
+static int qsfp_probe(struct i2c_client *client, const struct i2c_device_id *dev_id,
+						  struct qsfp_data **data)
+{
+	int status;
+	struct qsfp_data *qsfp;
+	
+	if (!sfp_i2c_check_functionality(client)) {
+        status = -EIO;
+        goto exit;		
+	}
+
+	qsfp = kzalloc(sizeof(struct qsfp_data), GFP_KERNEL);
+	if (!qsfp) {
+		status = -ENOMEM;
+		goto exit;
+	}
+
+	/* Register sysfs hooks */
+	status = sysfs_create_group(&client->dev.kobj, &qsfp_group);
+	if (status) {
+		goto exit_free;
+	}
+
+	/* init eeprom */
+	status = sfp_sysfs_eeprom_init(&client->dev.kobj, &qsfp->eeprom.bin);
+	if (status) {
+		goto exit_remove;
+	}
+
+	/* Bring QSFPs out of reset */
+	accton_i2c_cpld_write(0x62, 0x15, 0x3F);
+
+	*data = qsfp;
+	dev_info(&client->dev, "qsfp '%s'\n", client->name);
+
+	return 0;
+
+exit_remove:
+	sysfs_remove_group(&client->dev.kobj, &qsfp_group);
+exit_free:
+	kfree(qsfp);
+exit:
+
+	return status;	
+}
+
+static int sfp_device_probe(struct i2c_client *client,
+			const struct i2c_device_id *dev_id)
+{
+	struct sfp_port_data *data = NULL;
+
+	data = kzalloc(sizeof(struct sfp_port_data), GFP_KERNEL);
+	if (!data) {
+		return -ENOMEM;
+	}
+
+	i2c_set_clientdata(client, data);
+	mutex_init(&data->update_lock);
+	data->port 	 = dev_id->driver_data;
+	data->client = client;
+
+	if (dev_id->driver_data >= sfp1 && dev_id->driver_data <= sfp48) {
+		if (client->addr == SFP_EEPROM_A0_I2C_ADDR) {
+			data->driver_type = DRIVER_TYPE_SFP_MSA;
+			return sfp_msa_probe(client, dev_id, &data->msa);
+		}
+		else if (client->addr == SFP_EEPROM_A2_I2C_ADDR) {
+			data->driver_type = DRIVER_TYPE_SFP_DDM;
+			return sfp_ddm_probe(client, dev_id, &data->ddm);
+		}
+	}
+	else { /* sfp49 ~ sfp54 */
+		if (client->addr == SFP_EEPROM_A0_I2C_ADDR) {
+			data->driver_type = DRIVER_TYPE_QSFP;
+			return qsfp_probe(client, dev_id, &data->qsfp);
+		}
+	}
+	
+	return -ENODEV;
+}
+
+static int sfp_msa_remove(struct i2c_client *client, struct sfp_msa_data *data)
+{
+	sfp_sysfs_eeprom_cleanup(&client->dev.kobj, &data->eeprom.bin);
+	sysfs_remove_group(&client->dev.kobj, &sfp_msa_group);	
+	kfree(data);
+	return 0;
+}
+
+static int sfp_ddm_remove(struct i2c_client *client, struct sfp_ddm_data *data)
+{
+	sfp_sysfs_eeprom_cleanup(&client->dev.kobj, &data->eeprom.bin);
+	sysfs_remove_group(&client->dev.kobj, &sfp_ddm_group);
+	kfree(data);
+	return 0;
+}
+
+static int qfp_remove(struct i2c_client *client, struct qsfp_data *data)
+{
+	sfp_sysfs_eeprom_cleanup(&client->dev.kobj, &data->eeprom.bin);
+	sysfs_remove_group(&client->dev.kobj, &qsfp_group);
+	kfree(data);
+	return 0;
+}
+
+static int sfp_device_remove(struct i2c_client *client)
+{
+	struct sfp_port_data *data = i2c_get_clientdata(client);
+
+	switch (data->driver_type) {
+		case DRIVER_TYPE_SFP_MSA:
+			return sfp_msa_remove(client, data->msa);
+		case DRIVER_TYPE_SFP_DDM:
+			return sfp_ddm_remove(client, data->ddm);
+		case DRIVER_TYPE_QSFP:
+			return qfp_remove(client, data->qsfp);
+   	}
+
+	return 0;
+}
+
+static struct i2c_driver sfp_driver = {
+    .driver = {
+        .name     = DRIVER_NAME,
+    },
+    .probe        = sfp_device_probe,
+    .remove       = sfp_device_remove,
+    .id_table     = sfp_device_id,
+    .address_list = normal_i2c,
+};
+
+static int __init sfp_init(void)
+{
+	extern int platform_accton_as5512_54x(void);
+	if(!platform_accton_as5512_54x()) {
+		return -ENODEV;
+	}
+
+	return i2c_add_driver(&sfp_driver);
+}
+
+static void __exit sfp_exit(void)
+{
+	i2c_del_driver(&sfp_driver);
+}
+
+MODULE_AUTHOR("Brandon Chuang <brandon_chuang@accton.com.tw>");
+MODULE_DESCRIPTION("accton as5512_54x_sfp driver");
+MODULE_LICENSE("GPL");
+
+module_init(sfp_init);
+module_exit(sfp_exit);
+
+
